/** @file
  SSDT Serial AML Table Generator

  Copyright (c) 2019, ARM Limited. All rights reserved.
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/

#include <IndustryStandard/DebugPort2Table.h>
#include <Library/AcpiLib.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Protocol/AcpiTable.h>

// Module specific include files.
#include <AcpiTableGenerator.h>
#include <ConfigurationManagerObject.h>
#include <ConfigurationManagerHelper.h>
#include <Library/AmlLib/AmlLib.h>
#include <Library/TableHelperLib.h>
#include <Protocol/ConfigurationManagerProtocol.h>

// AML Code Include files generated by iASL Compiler
#include <SsdtSerialTemplate.hex>

/** SSDT Serial Port Table Generator

Requirements:
  The following Configuration Manager Object(s) are required by
  this Generator:
  - EArmObjSerialPortInfo
  - EArmObjSerialConsolePortInfo
*/

/** The PL011 UART address range length.
*/
#define PL011_UART_LENGTH                          0x1000

/** This macro expands to a function that retrieves the Generic Serial
    Port Information from the Configuration Manager.
*/
GET_OBJECT_LIST (
  EObjNameSpaceArm,
  EArmObjSerialPortInfo,
  CM_ARM_SERIAL_PORT_INFO
  );

/** This macro expands to a function that retrieves the Serial
    Port Information for the SPCR Port from the Configuration Manager.
*/
GET_OBJECT_LIST (
  EObjNameSpaceArm,
  EArmObjSerialConsolePortInfo,
  CM_ARM_SERIAL_PORT_INFO
  );

STATIC
CHAR8
AsciiFromHex (
  UINT8 x
  )
{
  if (x < 10) {
    return x + '0';
  }

  if (x < 16) {
    return x - 10 + 'A';
  }

  ASSERT (FALSE);
  return -1;
}

STATIC
EFI_STATUS
ValidateSerialPortInfo (
  CM_ARM_SERIAL_PORT_INFO         * SerialPortInfo
  )
{
  if (SerialPortInfo->BaseAddress == 0) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL: Uart port base address is invalid."
      " BaseAddress = 0x%lx\n",
      SerialPortInfo->BaseAddress
      ));
    return EFI_INVALID_PARAMETER;
  }

  if ((SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_ARM_PL011_UART) &&
      (SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_ARM_SBSA_GENERIC_UART_2X) &&
      (SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_ARM_SBSA_GENERIC_UART) &&
      (SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_FULL_16550) &&
      (SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_DCC)) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL: Uart port sybtype is invalid. PortSubtype = 0x%x\n",
      SerialPortInfo->PortSubtype
      ));
    return EFI_INVALID_PARAMETER;
  }

  DEBUG ((DEBUG_INFO, "SSDT-SERIAL: UART Configuration:\n"));
  DEBUG ((DEBUG_INFO, "  UART Base  = 0x%lx\n", SerialPortInfo->BaseAddress));
  DEBUG ((DEBUG_INFO, "  Clock      = %d\n", SerialPortInfo->Clock));
  DEBUG ((DEBUG_INFO, "  Baudrate   = %ld\n", SerialPortInfo->BaudRate));
  DEBUG ((DEBUG_INFO, "  Interrupt  = %d\n", SerialPortInfo->Interrupt));

  return EFI_SUCCESS;
}

STATIC
EFI_STATUS
SerializeSsdtTable (
  AML_ROOT_NODE_HANDLE              RootNodeHandle,
  EFI_ACPI_DESCRIPTION_HEADER    ** Table
  )
{
  EFI_STATUS    Status;
  UINT8       * TableBuffer;
  UINT32        TableSize;

  TableBuffer = NULL;
  TableSize = 0;

  Status = AmlSerializeTree (
             RootNodeHandle,
             TableBuffer,
             &TableSize
             );

  TableBuffer = (UINT8*)AllocateZeroPool (TableSize);
  if (TableBuffer == NULL) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL: Failed to allocate memory for Table Buffer," \
      " Status = %r\n",
      Status
      ));
    return EFI_OUT_OF_RESOURCES;
  }

  // Save the allocated Table buffer in the table list
  *Table = (EFI_ACPI_DESCRIPTION_HEADER*)TableBuffer;

  return AmlSerializeTree (
           RootNodeHandle,
           TableBuffer,
           &TableSize
           );
}

/**
  Find a node with a particular OpCode/SubOpCode in the tree,
  using an iterator.

  @param  Node               Start the research on the node after this node.
  @param  SearchedOpCode     The researched OpCode.
  @param  SearchedSubOpCode  The researched OpCode.
  @param  OutNode            If found, pointer to the first node
                             with the input OpCode/SubOpCode.
                             Otherwise, pointer to NULL.

  @retval  EFI_SUCCESS            The function completed successfully.
  @retval  EFI_INVALID_PARAMETER  Invalid parameter.
  @retval  EFI_NOT_FOUND          No matching node found.
 **/
EFI_STATUS
EFIAPI
SearchByOpCode (
  AML_NODE_HANDLE     Node,
  UINT8               SearchedOpCode,
  UINT8               SearchedSubOpCode,
  AML_NODE_HANDLE   * OutNode
)
{
  EFI_STATUS          Status;
  AML_NODE_HANDLE     CurrentNode;
  EAML_NODE_TYPE      NodeType;
  AML_TREE_ITERATOR * Iterator;

  UINT8               OpCode;
  UINT8               SubOpCode;
  UINT32              Size;

  if ((Node == NULL) ||
      (OutNode == NULL)) {
    ASSERT (0);
    return EFI_INVALID_PARAMETER;
  }

  // Initialize an iterator to search the node,
  // following the order of the bytestream.
  Status = AmlInitializeIterator (Node, EAmlIteratorLinear, &Iterator);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  // Get the next node, the research starts on the node after the input Node.
  Status = Iterator->GetNext (Iterator);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // For each node, check the OpCode/SubOpCode.
  while (1) {
    // Get the current node.
    Status = Iterator->GetNode (Iterator, &CurrentNode);
    if (EFI_ERROR (Status)) {
      ASSERT (0);
      goto error_handler;
    }

    // End of the tree.
    if (CurrentNode == NULL) {
      *OutNode = NULL;
      Status =  EFI_NOT_FOUND;
      goto error_handler;
    }

    // If the node is an object node, check the opcode.
    NodeType = AmlGetNodeType (CurrentNode);
    if (NodeType == EAmlNodeObject) {
      Status = AmlGetObjectNodeInfo (
                 CurrentNode,
                 &OpCode,
                 &SubOpCode,
                 &Size
                 );
      if (EFI_ERROR (Status)) {
        ASSERT (0);
        goto error_handler;
      }

      // Check the OpCode/SubOpCode.
      if ((SearchedOpCode == OpCode) && (SearchedSubOpCode == SubOpCode)) {
        *OutNode = CurrentNode;
        Status = EFI_SUCCESS;
        goto error_handler;
      }
    }

    // Get the next node.
    Status = Iterator->GetNext (Iterator);
    if (EFI_ERROR (Status)) {
      ASSERT (0);
      goto error_handler;
    }
  }

error_handler:
  if (Iterator != NULL) {
    AmlDeleteIterator (Iterator);
  }
  return Status;
}

/**
  Update the IRQ value of the extended interrupt resource data node.

  @param  ExtendedInterruptNode  Pointer to the an extended interrupt
                                 resource data node.
  @param  Irq                    Interrupt number.

  @retval  EFI_SUCCESS            The function completed successfully.
  @retval  EFI_INVALID_PARAMETER  Invalid parameter.
  @retval  EFI_OUT_OF_RESOURCES   Out of resources.
**/
EFI_STATUS
EFIAPI
UpdateExtendedInterruptNode (
  AML_NODE_HANDLE  ExtendedInterruptNode,
  UINT32           Irq
)
{
  EFI_STATUS                   Status;
  UINT8                      * QueryBuffer;
  UINT32                       QueryBufferSize;
  AML_RD_EXTENDED_INTERRUPT  * RdInterrupt;
  UINT32                     * InterruptNumber;

  if (ExtendedInterruptNode == NULL) {
    ASSERT (0);
    return EFI_INVALID_PARAMETER;
  }

  // Get the size of the ExtendedInterruptNode's buffer.
  Status = AmlGetDataNodeBuffer (
             ExtendedInterruptNode,
             NULL,
             &QueryBufferSize
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  // Allocate a buffer to fetch the data.
  QueryBuffer = AllocatePool (QueryBufferSize);
  if (QueryBuffer == NULL) {
    ASSERT (0);
    return EFI_OUT_OF_RESOURCES;
  }

  // Get the data.
  Status = AmlGetDataNodeBuffer (
             ExtendedInterruptNode,
             QueryBuffer,
             &QueryBufferSize
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  RdInterrupt = (AML_RD_EXTENDED_INTERRUPT*)QueryBuffer;

  // The IRQ field follows the AML_RD_EXTENDED_INTERRUPT header i.e. the Data[]
  InterruptNumber = (UINT32*)RdInterrupt->Data;

  // Update the IRQ
  *InterruptNumber = Irq;

  // Update interrupt node.
  Status = AmlUpdateDataNode (
             ExtendedInterruptNode,
             QueryBuffer,
             QueryBufferSize
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
  }

error_handler:
  if (QueryBuffer != NULL) {
    FreePool (QueryBuffer);
  }
  return Status;
}

/**
  Update the 32 bit Base address value of the 32BitFixedMemoryRange resource
  data node.

  @param  BaseAddressNode     Pointer to the BaseAddress Resource data Node.
  @param  BaseAddress         Base address.
  @param  BaseAddressLength   Base address length.

  @retval  EFI_SUCCESS            The function completed successfully.
  @retval  EFI_INVALID_PARAMETER  Invalid parameter.
  @retval  EFI_OUT_OF_RESOURCES   Out of resources.
**/
EFI_STATUS
EFIAPI
Update32BitFixedMemoryRangeNode (
  AML_NODE_HANDLE  BaseAddressNode,
  UINT32           BaseAddress,
  UINT32           BaseAddressLength
)
{
  EFI_STATUS                          Status;
  UINT8                             * QueryBuffer;
  UINT32                              QueryBufferSize;
  AML_RD_32_BIT_FIXED_MEMORY_RANGE  * RdBaseAddress;

  if (BaseAddressNode == NULL) {
    ASSERT (0);
    return EFI_INVALID_PARAMETER;
  }

  // Get the size of the BaseAddressNode's buffer.
  Status = AmlGetDataNodeBuffer (
             BaseAddressNode,
             NULL,
             &QueryBufferSize
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  // Allocate a buffer to fetch the data.
  QueryBuffer = AllocatePool (QueryBufferSize);
  if (QueryBuffer == NULL) {
    ASSERT (0);
    return EFI_OUT_OF_RESOURCES;
  }

  // Get the data.
  Status = AmlGetDataNodeBuffer (
             BaseAddressNode,
             QueryBuffer,
             &QueryBufferSize
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  RdBaseAddress = (AML_RD_32_BIT_FIXED_MEMORY_RANGE*)QueryBuffer;

  // Update the Base Address and Length
  RdBaseAddress->RangeBaseAddress = BaseAddress;
  RdBaseAddress->RangeLength = BaseAddressLength;

  // Update Base Address Resource Data node.
  Status = AmlUpdateDataNode (
             BaseAddressNode,
             QueryBuffer,
             QueryBufferSize
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
  }

error_handler:
  if (QueryBuffer != NULL) {
    FreePool (QueryBuffer);
  }
  return Status;
}


/**
  Update the device node name.

  @param  DeviceOpNode  Pointer to the DeviceOp Node.
  @param  Id            Index of the Serial Port (between 0x0 - 0xF).

  @retval  EFI_SUCCESS            The function completed successfully.
  @retval  EFI_INVALID_PARAMETER  Invalid parameter.
  @retval  EFI_OUT_OF_RESOURCES   Out of resources.
**/
EFI_STATUS
EFIAPI
UpdateDeviceNodeName (
  AML_NODE_HANDLE  DeviceOpNode,
  UINT8            Id
  )
{
  EFI_STATUS          Status;
  AML_NODE_HANDLE     NameNode;
  UINT8             * QueryBuffer;
  UINT32              QueryBufferSize;

  if (DeviceOpNode == NULL) {
    ASSERT (0);
    return EFI_INVALID_PARAMETER;
  }

  // The first fixed argument contains the device name.
  NameNode = AmlGetFixedArgument (DeviceOpNode, AML_OP_PARSE_INDEX_GET_TERM1);
  if (NameNode == NULL) {
    ASSERT (0);
    return EFI_NOT_FOUND;
  }

  // Get the size of the NameNode's buffer.
  Status = AmlGetDataNodeBuffer (
             NameNode,
             NULL,
             &QueryBufferSize
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  // Allocate a buffer to fetch the data.
  QueryBuffer = AllocatePool (QueryBufferSize);
  if (QueryBuffer == NULL) {
    ASSERT (0);
    return EFI_OUT_OF_RESOURCES;
  }

  // Get the data.
  Status = AmlGetDataNodeBuffer (
             NameNode,
             QueryBuffer,
             &QueryBufferSize
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // Update the Node Name.
  if (QueryBufferSize != 4) {
    ASSERT (0);
    goto error_handler;
  }


  QueryBuffer[3] = AsciiFromHex (Id);

  // Update Base Address Resource Data node.
  Status = AmlUpdateDataNode (
             NameNode,
             QueryBuffer,
             QueryBufferSize
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
  }

error_handler:
  if (QueryBuffer != NULL) {
    FreePool (QueryBuffer);
  }
  return Status;
}

STATIC
EFI_STATUS
FixupSerialPortInfo (
  AML_ROOT_NODE_HANDLE              RootNodeHandle,
  CM_ARM_SERIAL_PORT_INFO         * SerialPortInfo,
  EFI_ACPI_DESCRIPTION_HEADER    ** Table,
  UINT8                             Id
  )
{
  EFI_STATUS        Status;
  AML_NODE_HANDLE   BufferNode;
  AML_NODE_HANDLE   DeviceOpNode;
  AML_NODE_HANDLE   RdBaseAddressNode;
  AML_NODE_HANDLE   RdInterruptNode;
  AML_RD_HEADER     RdDataType;

  // Validate the Serial Port Info.
  Status = ValidateSerialPortInfo (SerialPortInfo);
  if (EFI_ERROR (Status)) {
    return Status;
  }

  // Find the DeviceOp node.
  Status = SearchByOpCode (RootNodeHandle, AML_EXT_OP, AML_EXT_DEVICE_OP, &DeviceOpNode);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  Status = UpdateDeviceNodeName (DeviceOpNode, Id);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  // Find the BufferOp node
  // Search for the first buffer node of the tree.
  Status = SearchByOpCode (RootNodeHandle, AML_BUFFER_OP, 0x00, &BufferNode);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  // Find and update the BaseAddress node
  // The first Resource Data element in the template is BaseAddress
  RdBaseAddressNode = AmlGetNextVariableArgument (BufferNode, NULL);
  if (RdBaseAddressNode == NULL) {
    ASSERT (0);
    return EFI_NOT_FOUND;
  }

  // Get information about the current node.
  Status = AmlGetResourceDataType (
             RdBaseAddressNode,
             &RdDataType
             );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  // Check if the data type is a 32bitFixedMemoryRange.
  if (!AmlRdCompareDescId (
         RdDataType,
         AML_RD_BUILD_LARGE_DESC_ID (EAmlRdlId32BitFixedMemoryRange)
         )) {
    ASSERT (0);
    return EFI_NOT_FOUND;
  }

  Status = Update32BitFixedMemoryRangeNode (
             RdBaseAddressNode,
             SerialPortInfo->BaseAddress,
             ((SerialPortInfo->BaseAddressLength < PL011_UART_LENGTH) ?
                 PL011_UART_LENGTH: SerialPortInfo->BaseAddressLength)
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  // Find and update the Interrupt node
  // The second Resource Data Element in the template is Interrupt
  RdInterruptNode = AmlGetNextVariableArgument (BufferNode, RdBaseAddressNode);

  // Get information about the current node.
  Status = AmlGetResourceDataType (
             RdInterruptNode,
             &RdDataType
             );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  // Check if the data type is an ExtendedInterrupt.
  if (!AmlRdCompareDescId (
         RdDataType,
         AML_RD_BUILD_LARGE_DESC_ID (EAmlRdlIdExtendedInterrupt)
         )) {
    ASSERT (0);
    return EFI_NOT_FOUND;
  }

  Status = UpdateExtendedInterruptNode (
             RdInterruptNode,
             SerialPortInfo->Interrupt
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  Status = SerializeSsdtTable (
             RootNodeHandle,
             Table
             );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL: Failed to Serialize SSDT Table Data."
      " Status = %r\n",
      Status
      ));
  }
  return Status;
}

/** Free any resources allocated for constructing the tables.

  @param [in]      This           Pointer to the ACPI table generator.
  @param [in]      AcpiTableInfo  Pointer to the ACPI Table Info.
  @param [in]      CfgMgrProtocol Pointer to the Configuration Manager
                                  Protocol Interface.
  @param [in, out] Table          Pointer to the list of ACPI Table(s).
  @param [in]      TableCount     Number of ACPI table(s).

  @retval EFI_SUCCESS           The resources were freed successfully.
  @retval EFI_INVALID_PARAMETER The table pointer is NULL or invalid.
**/
STATIC
EFI_STATUS
FreeSsdtSerialTableResourcesEx (
  IN      CONST ACPI_TABLE_GENERATOR                   * CONST This,
  IN      CONST CM_STD_OBJ_ACPI_TABLE_INFO             * CONST AcpiTableInfo,
  IN      CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL   * CONST CfgMgrProtocol,
  IN OUT        EFI_ACPI_DESCRIPTION_HEADER          *** CONST Table,
  IN      CONST UINTN                                          TableCount
  )
{
  EFI_ACPI_DESCRIPTION_HEADER    ** TableList = NULL;
  UINTN                             Index;

  ASSERT (This != NULL);
  ASSERT (AcpiTableInfo != NULL);
  ASSERT (CfgMgrProtocol != NULL);
  ASSERT (AcpiTableInfo->TableGeneratorId == This->GeneratorID);
  ASSERT (AcpiTableInfo->AcpiTableSignature == This->AcpiTableSignature);

  if ((Table == NULL) || (*Table == NULL)) {
    DEBUG ((DEBUG_ERROR, "ERROR: SSDT-SERIAL: Invalid Table Pointer\n"));
    ASSERT ((Table != NULL) && (*Table != NULL));
    return EFI_INVALID_PARAMETER;
  }

  TableList = *Table;

  for (Index = 0; Index < TableCount; Index++) {
    if (TableList[Index] != NULL) {
      // Free the table data
      FreePool (TableList[Index]);
      TableList[Index] = NULL;
    }
  }

  // Free the table list
  FreePool (*Table);
  *Table = NULL;
  return EFI_SUCCESS;
}

/** Construct the ACPI table using the ACPI table data provided.

  This function invokes the Configuration Manager protocol interface
  to get the required hardware information for generating the ACPI
  table.

  If this function allocates any resources then they must be freed
  in the FreeXXXXTableResourcesEx function.

  @param [in]  This           Pointer to the table generator.
  @param [in]  AcpiTableInfo  Pointer to the ACPI Table Info.
  @param [in]  CfgMgrProtocol Pointer to the Configuration Manager
                              Protocol Interface.
  @param [out] Table          Pointer to a list of generated ACPI table(s).
  @param [out] TableCount     Number of generated ACPI table(s).

  @retval EFI_SUCCESS           Table generated successfully.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
**/
STATIC
EFI_STATUS
EFIAPI
BuildSsdtSerialTableEx (
  IN  CONST ACPI_TABLE_GENERATOR                   *       This,
  IN  CONST CM_STD_OBJ_ACPI_TABLE_INFO             * CONST AcpiTableInfo,
  IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL   * CONST CfgMgrProtocol,
  OUT       EFI_ACPI_DESCRIPTION_HEADER          ***       Table,
  OUT       UINTN                                  * CONST TableCount
  )
{
  EFI_STATUS                        Status;
  EFI_STATUS                        Status1;
  EFI_ACPI_DESCRIPTION_HEADER     * SsdtSerialPortTemplate;
  UINT32                            SerialPortCount;
  UINT32                            TotalSerialPortCount;
  CM_ARM_SERIAL_PORT_INFO         * SpcrSerialPortInfo;
  CM_ARM_SERIAL_PORT_INFO         * SerialPortInfo;
  EFI_ACPI_DESCRIPTION_HEADER    ** TableList = NULL;
  UINT8                             Index;
  AML_ROOT_NODE_HANDLE              RootNodeHandle;

  ASSERT (This != NULL);
  ASSERT (AcpiTableInfo != NULL);
  ASSERT (CfgMgrProtocol != NULL);
  ASSERT (Table != NULL);
  ASSERT (AcpiTableInfo->TableGeneratorId == This->GeneratorID);

  *Table = NULL;

  SerialPortCount = 0;
  TotalSerialPortCount = 0;

  // Get information about the serial ports available on the platform
  SerialPortInfo = NULL;
  Status = GetEArmObjSerialPortInfo (
             CfgMgrProtocol,
             CM_NULL_TOKEN,
             &SerialPortInfo,
             &SerialPortCount
             );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_INFO,
      "INFO: SSDT-SERIAL: Failed to get serial port information."
      " Status = %r\n",
      Status
      ));
    // We do not fail here as the platform may not have
    // serial ports for generic purpose
  }

  TotalSerialPortCount += SerialPortCount;

  if (TotalSerialPortCount > 16) {
    DEBUG ((
      DEBUG_INFO,
      "INFO: SSDT-SERIAL: Maximum serial ports supported is 16."
      " Status = %r\n",
      Status
      ));
      return EFI_UNSUPPORTED;
  }

  // SBBR mandates that a SPCR port must be available on a compliant
  // plaform. It also requires that this port is described in the
  // ACPI definition block
  SpcrSerialPortInfo = NULL;
  Status = GetEArmObjSerialConsolePortInfo (
             CfgMgrProtocol,
             CM_NULL_TOKEN,
             &SpcrSerialPortInfo,
             NULL
             );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL: SBBR compliance error."
      " Serial port information not found for SPCR port."
      " Status = %r\n",
      Status
      ));
    // We dont fail here. We continue with error.
  } else {
    TotalSerialPortCount++;
  }

  if (TotalSerialPortCount == 0) {
    // Platform does not have any serial ports.
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL: Serial port information not found."
      " Status = %r\n",
      Status
      ));
    return EFI_NOT_FOUND;
  }

  // Update the table count
  *TableCount = TotalSerialPortCount;

  // Allocate storage for the Table list
  TableList = (EFI_ACPI_DESCRIPTION_HEADER**)
              AllocateZeroPool (
                (TotalSerialPortCount * sizeof (EFI_ACPI_DESCRIPTION_HEADER*))
                );
  if (TableList == NULL) {
    Status = EFI_OUT_OF_RESOURCES;
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL: Failed to allocate memory for Table List," \
      " Status = %r\n",
      Status
      ));
    goto error_handler;
  }

  // Update the table list pointer
  *Table = TableList;

  // Parse Ssdt Serial Port Template
  SsdtSerialPortTemplate = (EFI_ACPI_DESCRIPTION_HEADER*)
                              ssdtserialtemplate_aml_code;

  RootNodeHandle = NULL;
  Status = AmlParseDefinitionBlock (
             SsdtSerialPortTemplate,
             &RootNodeHandle
             );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_INFO,
      "ERROR: SSDT-SERIAL: Failed to parse SSDT Serial Template."
      " Status = %r\n",
      Status
      ));
    goto error_handler;
  }

  Index = 0;
  while (Index < SerialPortCount) {
    Status = FixupSerialPortInfo (
              RootNodeHandle,
              &SerialPortInfo[Index],
              &TableList[Index],
              Index
              );
    if (EFI_ERROR (Status)) {
      DEBUG ((
        DEBUG_INFO,
        "ERROR: SSDT-SERIAL: Failed to add SSDT Serial Table."
        " Status = %r\n",
        Status
        ));
      goto error_handler;
    }
    Index++;
  } // while

  // Add SPCR Port if present
  if (SpcrSerialPortInfo != NULL) {
    Status = FixupSerialPortInfo (
              RootNodeHandle,
              SpcrSerialPortInfo,
              &TableList[Index],
              Index
              );
    if (EFI_ERROR (Status)) {
      DEBUG ((
        DEBUG_ERROR,
        "ERROR: SSDT-SERIAL: Failed to add SSDT Serial Table for SPCR port."
        " Status = %r\n",
        Status
        ));
      goto error_handler;
    }
  }

  goto exit_handler;

error_handler:

  // Free up the allocated resources in case of an error
  FreeSsdtSerialTableResourcesEx (
    This,
    AcpiTableInfo,
    CfgMgrProtocol,
    Table,
    *TableCount
    );

exit_handler:
  if (RootNodeHandle != NULL) {
    Status1 = AmlDeleteTree (RootNodeHandle);
    if (EFI_ERROR (Status1)) {
      DEBUG ((
        DEBUG_ERROR,
        "ERROR: SSDT-SERIAL: Failed to add SSDT Serial Table for SPCR port."
        " Status = %r\n",
        Status1
        ));
      // If Status was success but we failed to delete the Aml Tree
      // return Status1 else return the original error code i.e. Status
      if (!EFI_ERROR (Status)) {
        return Status1;
      }
    }
  }

  return Status;
}

/** This macro defines the Raw Generator revision.
*/
#define SSDT_SERIAL_GENERATOR_REVISION CREATE_REVISION (1, 0)

/** The interface for the Raw Table Generator.
*/
STATIC
CONST
ACPI_TABLE_GENERATOR SsdtSerialGenerator = {
  // Generator ID
  CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdSsdtSerial),
  // Generator Description
  L"ACPI.STD.SSDT.SERIAL.GENERATOR",
  // ACPI Table Signature
  EFI_ACPI_6_3_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE,
  // ACPI Table Revision - Unused
  0,
  // Minimum ACPI Table Revision - Unused
  0,
  // Creator ID
  TABLE_GENERATOR_CREATOR_ID_ARM,
  // Creator Revision
  SSDT_SERIAL_GENERATOR_REVISION,
  // Build Table function not implemented
  // as this generator implements the extended
  // version
  NULL,
  NULL,
  // Extended build table function
  BuildSsdtSerialTableEx,
  // Free resources allocated by extended build table interface
  FreeSsdtSerialTableResourcesEx
};

/** Register the Generator with the ACPI Table Factory.

  @param [in]  ImageHandle  The handle to the image.
  @param [in]  SystemTable  Pointer to the System Table.

  @retval EFI_SUCCESS           The Generator is registered.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_ALREADY_STARTED   The Generator for the Table ID
                                is already registered.
**/
EFI_STATUS
EFIAPI
AcpiSsdtSerialLibConstructor (
  IN CONST EFI_HANDLE                ImageHandle,
  IN       EFI_SYSTEM_TABLE  * CONST SystemTable
  )
{
  EFI_STATUS  Status;

  Status = RegisterAcpiTableGenerator (&SsdtSerialGenerator);
  DEBUG ((
    DEBUG_INFO,
    "SSDT-SERIAL: Register Generator. Status = %r\n",
    Status
    ));
  ASSERT_EFI_ERROR (Status);
  return Status;
}

/** Deregister the Generator from the ACPI Table Factory.

  @param [in]  ImageHandle  The handle to the image.
  @param [in]  SystemTable  Pointer to the System Table.

  @retval EFI_SUCCESS           The Generator is deregistered.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND         The Generator is not registered.
**/
EFI_STATUS
EFIAPI
AcpiSsdtSerialLibDestructor (
  IN CONST EFI_HANDLE                ImageHandle,
  IN       EFI_SYSTEM_TABLE  * CONST SystemTable
  )
{
  EFI_STATUS  Status;

  Status = DeregisterAcpiTableGenerator (&SsdtSerialGenerator);

  DEBUG ((
    DEBUG_INFO,
    "SSDT-SERIAL: Deregister Generator. Status = %r\n",
    Status
    ));
  ASSERT_EFI_ERROR (Status);
  return Status;
}
