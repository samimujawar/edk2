/** @file
  SSDT Serial Port Table Generator

  Copyright (c) 2019 - 2020, ARM Limited. All rights reserved.<BR>

  SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Reference(s):
  - Generic ACPI for Arm Components 1.0 Platform Design Document
  - Arm Server Base Boot Requirements 1.2 Platform Design Document
**/

#include <IndustryStandard/DebugPort2Table.h>
#include <Library/AcpiLib.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Protocol/AcpiTable.h>

// Module specific include files.
#include <AcpiTableGenerator.h>
#include <ConfigurationManagerObject.h>
#include <ConfigurationManagerHelper.h>
#include <Library/AmlLib/AmlLib.h>
#include <Library/TableHelperLib.h>
#include <Protocol/ConfigurationManagerProtocol.h>

// Include files generated by the AmlToHex.py script.
// Contain AML bytecode.
#include <SsdtSerialPortTemplate.hex>

/** SSDT Serial Port Table Generator.

  Requirements:
  The following Configuration Manager Object(s) are required by
  this Generator:
  - EArmObjSerialPortInfo
  - EArmObjSerialConsolePortInfo
*/

#define AML_NAME_SEG_SIZE                                4U

/** UART address range length.
*/
#define MIN_UART_ADDRESS_LENGTH                          0x1000

/** This macro expands to a function that retrieves the Serial
    Port Information from the Configuration Manager.
*/
GET_OBJECT_LIST (
  EObjNameSpaceArm,
  EArmObjSerialPortInfo,
  CM_ARM_SERIAL_PORT_INFO
  );

/** This macro expands to a function that retrieves the Serial Console
    Port Information for the SPCR Port from the Configuration Manager.
*/
GET_OBJECT_LIST (
  EObjNameSpaceArm,
  EArmObjSerialConsolePortInfo,
  CM_ARM_SERIAL_PORT_INFO
  );

/** Convert a hex number to its Ascii code.

 @param [in]  x   Hex number to convert.
                  Must be 0 <= x < 16.

 @return The ascii code corresponding to x.
**/
STATIC
UINT8
EFIAPI
AsciiFromHex (
  IN  UINT8   x
  )
{
  if (x < 10) {
    return (UINT8)(x + '0');
  }

  if (x < 16) {
    return (UINT8)(x - 10 + 'A');
  }

  ASSERT (FALSE);
  return (UINT8)0;
}

/** Check the Serial Port Information object.

  @param [in]  SerialPortInfo   Serial Port Information structure.

  @retval  EFI_SUCCESS            The function completed successfully.
  @retval  EFI_INVALID_PARAMETER  Invalid parameter.
**/
STATIC
EFI_STATUS
EFIAPI
ValidateSerialPortInfo (
  IN  CM_ARM_SERIAL_PORT_INFO   * SerialPortInfo
  )
{
  if (SerialPortInfo->BaseAddress == 0) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL-PORT: UART port base address is invalid."
      " BaseAddress = 0x%llx\n",
      SerialPortInfo->BaseAddress
      ));
    ASSERT (0);
    return EFI_INVALID_PARAMETER;
  }

  if ((SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_ARM_PL011_UART) &&
      (SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_ARM_SBSA_GENERIC_UART_2X) &&
      (SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_ARM_SBSA_GENERIC_UART) &&
      (SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_FULL_16550) &&
      (SerialPortInfo->PortSubtype !=
      EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_DCC)) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL-PORT:",
      " UART port subtype is invalid. PortSubtype = 0x%x\n",
      SerialPortInfo->PortSubtype
      ));
    ASSERT (0);
    return EFI_INVALID_PARAMETER;
  }

  DEBUG ((DEBUG_INFO, "SSDT-SERIAL-PORT: UART Configuration:\n"));
  DEBUG ((DEBUG_INFO, "  UART Base  = 0x%llx\n", SerialPortInfo->BaseAddress));
  DEBUG ((
    DEBUG_INFO,
    "  Length     = 0x%llx\n",
    SerialPortInfo->BaseAddressLength
    ));
  DEBUG ((DEBUG_INFO, "  Clock      = %lu\n", SerialPortInfo->Clock));
  DEBUG ((DEBUG_INFO, "  BaudRate   = %llu\n", SerialPortInfo->BaudRate));
  DEBUG ((DEBUG_INFO, "  Interrupt  = %lu\n", SerialPortInfo->Interrupt));

  return EFI_SUCCESS;
}

/** Fixup the Serial Port Information in the AML tree.

  For each template value:
   - find the node to update;
   - update the value.

  @param  [in] RootNodeHandle   Pointer to the root of the AML tree.
  @param  [in] SerialPortInfo   Pointer to a Serial Port Information
                                structure.
                                Get the Serial Port Information from there.
  @param  [in]  Id              Index of the Serial Port (between 0x0 - 0xF).
  @param  [out] Table           On return, hold the serialized
                                definition block.

  @retval  EFI_SUCCESS            The function completed successfully.
  @retval  EFI_INVALID_PARAMETER  Invalid parameter.
  @retval  EFI_NOT_FOUND          Could not find information.
  @retval  EFI_OUT_OF_RESOURCES   Out of resources.
**/
STATIC
EFI_STATUS
EFIAPI
FixupSerialPortInfo (
  IN  OUT AML_ROOT_NODE_HANDLE              RootNodeHandle,
  IN      CM_ARM_SERIAL_PORT_INFO         * SerialPortInfo,
  IN      UINT8                             Id,
      OUT EFI_ACPI_DESCRIPTION_HEADER    ** Table
  )
{
  EFI_STATUS                Status;
  EFI_STATUS                Status1;

  AML_OBJECT_NODE_HANDLE    NameOpUidNode;

  AML_OBJECT_NODE_HANDLE    NameOpCrsNode;
  AML_DATA_NODE_HANDLE      QWordRdNode;
  AML_DATA_NODE_HANDLE      InterruptRdNode;

  AML_OBJECT_NODE_HANDLE    DeviceNode;
  AML_ROOT_NODE_HANDLE      CloneRootNodeHandle;

  CHAR8                     NewName[AML_NAME_SEG_SIZE];

  // Clone the AML tree so that the original template can be reused.
  Status = AmlCloneTree (RootNodeHandle, &CloneRootNodeHandle);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    return Status;
  }

  // Validate the Serial Port Info.
  Status = ValidateSerialPortInfo (SerialPortInfo);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // Get the _UID object defined by the "Name ()" statement.
  Status = AmlFindNode (
             CloneRootNodeHandle,
             "\\_SB_.COM0._UID",
             &NameOpUidNode
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // Update the _UID value.
  Status = AmlNameOpUidUpdateValue (NameOpUidNode, (UINT64)Id);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // Get the "_CRS" object defined by the "Name ()" statement.
  Status = AmlFindNode (
             CloneRootNodeHandle,
             "\\_SB_.COM0._CRS",
             &NameOpCrsNode
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // Get the first Rd node in the "_CRS" object.
  Status = AmlNameOpCrsGetFirstRdNode (NameOpCrsNode, &QWordRdNode);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // Update the Serial Port base address and length.
  Status = AmlUpdateRdQWord (
             QWordRdNode,
             SerialPortInfo->BaseAddress,
             ((SerialPortInfo->BaseAddressLength < MIN_UART_ADDRESS_LENGTH) ?
                 MIN_UART_ADDRESS_LENGTH: SerialPortInfo->BaseAddressLength)
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // Get the Interrupt node.
  // It is the second Resource Data element in the NameOpCrsNode's
  // variable list of arguments.
  Status = AmlNameOpCrsGetNextRdNode (QWordRdNode, &InterruptRdNode);
  if (EFI_ERROR (Status)  ||
      (InterruptRdNode == NULL)) {
    ASSERT (0);
    goto error_handler;
  }

  // Update the interrupt number.
  Status = AmlUpdateRdInterrupt (
             InterruptRdNode,
             SerialPortInfo->Interrupt
             );
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // Get the COM0 variable defined by the "Device ()" statement.
  // Do this step at the end, otherwise the generic name "COM0" will not be
  // valid anymore and the FindNode function will fail.
  Status = AmlFindNode (CloneRootNodeHandle, "\\_SB_.COM0", &DeviceNode);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  // Update the Device's name.
  NewName[0] = 'C';
  NewName[1] = 'O';
  NewName[2] = 'M';
  NewName[3] = AsciiFromHex (Id);
  Status = AmlDeviceOpUpdateName (DeviceNode, NewName);
  if (EFI_ERROR (Status)) {
    ASSERT (0);
    goto error_handler;
  }

  Status = AmlSerializeDefinitionBlock (
             CloneRootNodeHandle,
             Table
             );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL-PORT: Failed to Serialize SSDT Table Data."
      " Status = %r\n",
      Status
      ));
    ASSERT (0);
  }

error_handler:
  Status1 = AmlDeleteTree (CloneRootNodeHandle);
  if (EFI_ERROR (Status1)) {
    ASSERT (0);
    if (!EFI_ERROR (Status)) {
      return Status1;
    }
  }
  return Status;
}

/** Free any resources allocated for constructing the tables.

  @param [in]      This           Pointer to the ACPI table generator.
  @param [in]      AcpiTableInfo  Pointer to the ACPI Table Info.
  @param [in]      CfgMgrProtocol Pointer to the Configuration Manager
                                  Protocol Interface.
  @param [in, out] Table          Pointer to the list of ACPI Table(s).
  @param [in]      TableCount     Number of ACPI table(s).

  @retval EFI_SUCCESS           The resources were freed successfully.
  @retval EFI_INVALID_PARAMETER The table pointer is NULL or invalid.
**/
STATIC
EFI_STATUS
EFIAPI
FreeSsdtSerialTableResourcesEx (
  IN      CONST ACPI_TABLE_GENERATOR                   * CONST This,
  IN      CONST CM_STD_OBJ_ACPI_TABLE_INFO             * CONST AcpiTableInfo,
  IN      CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL   * CONST CfgMgrProtocol,
  IN OUT        EFI_ACPI_DESCRIPTION_HEADER          *** CONST Table,
  IN      CONST UINTN                                          TableCount
  )
{
  EFI_ACPI_DESCRIPTION_HEADER    ** TableList = NULL;
  UINTN                             Index;

  ASSERT (This != NULL);
  ASSERT (AcpiTableInfo != NULL);
  ASSERT (CfgMgrProtocol != NULL);
  ASSERT (AcpiTableInfo->TableGeneratorId == This->GeneratorID);
  ASSERT (AcpiTableInfo->AcpiTableSignature == This->AcpiTableSignature);

  if ((Table == NULL) || (*Table == NULL)) {
    DEBUG ((DEBUG_ERROR, "ERROR: SSDT-SERIAL-PORT: Invalid Table Pointer\n"));
    ASSERT ((Table != NULL) && (*Table != NULL));
    return EFI_INVALID_PARAMETER;
  }

  TableList = *Table;

  for (Index = 0; Index < TableCount; Index++) {
    if (TableList[Index] != NULL) {
      // Free the table data
      FreePool (TableList[Index]);
      TableList[Index] = NULL;
    }
  }

  // Free the table list
  FreePool (*Table);
  *Table = NULL;
  return EFI_SUCCESS;
}

/** Construct the ACPI table using the ACPI table data provided.

  This function invokes the Configuration Manager protocol interface
  to get the required hardware information for generating the ACPI
  table.

  If this function allocates any resources then they must be freed
  in the FreeXXXXTableResourcesEx function.

  @param [in]  This           Pointer to the table generator.
  @param [in]  AcpiTableInfo  Pointer to the ACPI Table Info.
  @param [in]  CfgMgrProtocol Pointer to the Configuration Manager
                              Protocol Interface.
  @param [out] Table          Pointer to a list of generated ACPI table(s).
  @param [out] TableCount     Number of generated ACPI table(s).

  @retval EFI_SUCCESS           Table generated successfully.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND          Could not find information.
  @retval EFI_OUT_OF_RESOURCES   Could not allocate memory.
**/
STATIC
EFI_STATUS
EFIAPI
BuildSsdtSerialTableEx (
  IN  CONST ACPI_TABLE_GENERATOR                   *       This,
  IN  CONST CM_STD_OBJ_ACPI_TABLE_INFO             * CONST AcpiTableInfo,
  IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL   * CONST CfgMgrProtocol,
  OUT       EFI_ACPI_DESCRIPTION_HEADER          ***       Table,
  OUT       UINTN                                  * CONST TableCount
  )
{
  EFI_STATUS                        Status;
  EFI_STATUS                        Status1;
  EFI_ACPI_DESCRIPTION_HEADER     * SsdtSerialPortTemplate;
  UINT32                            SerialPortCount;
  UINT32                            TotalSerialPortCount;
  CM_ARM_SERIAL_PORT_INFO         * SpcrSerialPortInfo;
  CM_ARM_SERIAL_PORT_INFO         * SerialPortInfo;
  EFI_ACPI_DESCRIPTION_HEADER    ** TableList = NULL;
  UINT8                             Index;
  AML_ROOT_NODE_HANDLE              RootNodeHandle;

  ASSERT (This != NULL);
  ASSERT (AcpiTableInfo != NULL);
  ASSERT (CfgMgrProtocol != NULL);
  ASSERT (Table != NULL);
  ASSERT (AcpiTableInfo->TableGeneratorId == This->GeneratorID);

  *Table = NULL;
  RootNodeHandle = NULL;
  TotalSerialPortCount = 0;

  // Get information about the serial ports available on the platform.
  SerialPortInfo = NULL;
  Status = GetEArmObjSerialPortInfo (
             CfgMgrProtocol,
             CM_NULL_TOKEN,
             &SerialPortInfo,
             &SerialPortCount
             );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_INFO,
      "INFO: SSDT-SERIAL-PORT: Serial Port Information not provided."
      "Platform may not have serial ports for generic purpose."
      " Status = %r\n",
      Status
      ));
    // We do not fail here as the platform may not have
    // serial ports for generic purpose
  }

  TotalSerialPortCount += SerialPortCount;

  // SBBR mandates that a SPCR port must be available on a compliant
  // platform. It also requires that this port is described in the
  // ACPI definition block
  SpcrSerialPortInfo = NULL;
  Status = GetEArmObjSerialConsolePortInfo (
             CfgMgrProtocol,
             CM_NULL_TOKEN,
             &SpcrSerialPortInfo,
             NULL
             );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL-PORT: SBBR compliance error."
      " Serial Port Information not found for SPCR port."
      " Status = %r\n",
      Status
      ));
    // We don't fail here. We continue with error.
  } else {
    TotalSerialPortCount++;
  }

  if (TotalSerialPortCount > 16) {
    DEBUG ((
      DEBUG_ERROR,
      "Maximum 16 serial ports supported."
      " Status = %r\n",
      Status
      ));
      return EFI_UNSUPPORTED;
  }

  if (TotalSerialPortCount == 0) {
    // Platform does not have any serial ports.
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL-PORT: Serial port information not found."
      " Status = %r\n",
      Status
      ));
    ASSERT (0);
    return EFI_NOT_FOUND;
  }

  // Update the table count
  *TableCount = TotalSerialPortCount;

  // Allocate storage for the Table list
  TableList = (EFI_ACPI_DESCRIPTION_HEADER**)
              AllocateZeroPool (
                (TotalSerialPortCount * sizeof (EFI_ACPI_DESCRIPTION_HEADER*))
                );
  if (TableList == NULL) {
    Status = EFI_OUT_OF_RESOURCES;
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL-PORT: Failed to allocate memory for Table List," \
      " Status = %r\n",
      Status
      ));
    ASSERT (0);
    goto error_handler;
  }

  // Update the table list pointer.
  *Table = TableList;

  // Parse the Ssdt Serial Port Template.
  SsdtSerialPortTemplate = (EFI_ACPI_DESCRIPTION_HEADER*)
                              ssdtserialporttemplate_aml_code;

  Status = AmlParseDefinitionBlock (
             SsdtSerialPortTemplate,
             &RootNodeHandle
             );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: SSDT-SERIAL-PORT: Failed to parse SSDT Serial Port Template."
      " Status = %r\n",
      Status
      ));
    ASSERT (0);
    goto error_handler;
  }

  Index = 0;
  while (Index < SerialPortCount) {
    Status = FixupSerialPortInfo (
              RootNodeHandle,
              &SerialPortInfo[Index],
              Index,
              &TableList[Index]
              );
    if (EFI_ERROR (Status)) {
      DEBUG ((
        DEBUG_ERROR,
        "ERROR: SSDT-SERIAL-PORT: Failed to add SSDT Serial Port Table."
        " Status = %r\n",
        Status
        ));
      ASSERT (0);
      goto error_handler;
    }
    Index++;
  } // while

  // Add SPCR Port if present.
  if (SpcrSerialPortInfo != NULL) {
    Status = FixupSerialPortInfo (
               RootNodeHandle,
               SpcrSerialPortInfo,
               Index,
               &TableList[Index]
               );
    if (EFI_ERROR (Status)) {
      DEBUG ((
        DEBUG_ERROR,
        "ERROR: SSDT-SERIAL-PORT:"
        " Failed to add SSDT Serial Port Table for SPCR port."
        " Status = %r\n",
        Status
        ));
      ASSERT (0);
    }
  }

error_handler:
  // Cleanup
  if (RootNodeHandle != NULL) {
    Status1 = AmlDeleteTree (RootNodeHandle);
    if (EFI_ERROR (Status1)) {
      DEBUG ((
        DEBUG_ERROR,
        "ERROR: SSDT-SERIAL-PORT:",
        "Failed to add SSDT Serial Port Table for SPCR port."
        " Status = %r\n",
        Status1
        ));
      ASSERT (0);
      // If Status was success but we failed to delete the AML Tree
      // return Status1 else return the original error code i.e. Status.
      if (!EFI_ERROR (Status)) {
        return Status1;
      }
    }
  }

  return Status;
}

/** This macro defines the Raw Generator revision.
*/
#define SSDT_SERIAL_GENERATOR_REVISION CREATE_REVISION (1, 0)

/** The interface for the Raw Table Generator.
*/
STATIC
CONST
ACPI_TABLE_GENERATOR SsdtSerialGenerator = {
  // Generator ID
  CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdSsdtSerial),
  // Generator Description
  L"ACPI.STD.SSDT.SERIAL.GENERATOR",
  // ACPI Table Signature
  EFI_ACPI_6_3_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE,
  // ACPI Table Revision - Unused
  0,
  // Minimum ACPI Table Revision - Unused
  0,
  // Creator ID
  TABLE_GENERATOR_CREATOR_ID_ARM,
  // Creator Revision
  SSDT_SERIAL_GENERATOR_REVISION,
  // Build Table function not implemented
  // as this generator implements the extended
  // version
  NULL,
  NULL,
  // Extended build table function
  BuildSsdtSerialTableEx,
  // Free resources allocated by extended build table interface
  FreeSsdtSerialTableResourcesEx
};

/** Register the Generator with the ACPI Table Factory.

  @param [in]  ImageHandle  The handle to the image.
  @param [in]  SystemTable  Pointer to the System Table.

  @retval EFI_SUCCESS           The Generator is registered.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_ALREADY_STARTED   The Generator for the Table ID
                                is already registered.
**/
EFI_STATUS
EFIAPI
AcpiSsdtSerialPortLibConstructor (
  IN  EFI_HANDLE           ImageHandle,
  IN  EFI_SYSTEM_TABLE  *  SystemTable
  )
{
  EFI_STATUS  Status;

  Status = RegisterAcpiTableGenerator (&SsdtSerialGenerator);
  DEBUG ((
    DEBUG_INFO,
    "SSDT-SERIAL-PORT: Register Generator. Status = %r\n",
    Status
    ));
  ASSERT_EFI_ERROR (Status);
  return Status;
}

/** Deregister the Generator from the ACPI Table Factory.

  @param [in]  ImageHandle  The handle to the image.
  @param [in]  SystemTable  Pointer to the System Table.

  @retval EFI_SUCCESS           The Generator is deregistered.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND         The Generator is not registered.
**/
EFI_STATUS
EFIAPI
AcpiSsdtSerialPortLibDestructor (
  IN  EFI_HANDLE           ImageHandle,
  IN  EFI_SYSTEM_TABLE  *  SystemTable
  )
{
  EFI_STATUS  Status;

  Status = DeregisterAcpiTableGenerator (&SsdtSerialGenerator);

  DEBUG ((
    DEBUG_INFO,
    "SSDT-SERIAL-PORT: Deregister Generator. Status = %r\n",
    Status
    ));
  ASSERT_EFI_ERROR (Status);
  return Status;
}
